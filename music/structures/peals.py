from . permutations import InterestingPermutations, transposePermutation
from .plainChanges import PlainChanges
from sympy.combinatorics import Permutation as p_

class Peals(InterestingPermutations):
    """Use permutations to make peals and represent peals as permutations.
    
    http://www.gutenberg.org/files/18567/18567-h/18567-h.htm"""
    def __init__(self):
        InterestingPermutations.__init__(self)
        self.peals={}
        self.makeRotateHalfs() # original and the rotation r that r*r=e. Alternate r1*r2=e if nelements==odd
        self.makeMirror() # original and miror
        self.makeFullRotations() # original and each rotation clockwise (0->n-1)
        self.makeFullMirrors() # sequences to fit overall sizes or not..
        self.makeOtherFullCycles() # generated by permutations with all elements while not a rotation or a mirror. # non-topological?
        self.canonicalPeal() # with the hunts, etc. 
        self.transpositionsPeal(self.peals["rotation_peal"][1])
        self.TwentyAllOver() # 
        self.anEightAndForty() # 
    def canonicalPeal(self,hunts=None):
        domain=list(range(self.nelements))
        if hunts==None:
            hunts={}
            if len(self.nelements)<5:
                hunts["hunt1"]=dict(level=1,index=0,status="started",direction="up",next_=None)
            else:
                hunts["hunt1"]=dict(level=1,index=0,direction="up",next_="hunt2")
                hunts["hunt2"]=dict(level=2,index=1,direction="up",next_=None)
        peal=[self.applyStep(domain,hunts)]
        total_perm=getStepAsPermutation(hunts)
        while total_perm!=sympy.combinatorics.Permutation(0):
            sequence,hunts=self.getStepAsPermutation(peal[-1],hunts)
            peal+=[sequence]
        self.peal=peal
    def getStepAsPermutation(self,hunts,hunt=None):
        if hunt==None:
            hunt="hunt1"
        hunt=hunts[hunt]
        direction=hunt["direction"]
        assert direction in {"up","down"}
        position=hunt["position"]
        swap_with=(position-1,position+1)[direction=="up"]
        if swap_with in domain:
            swap=self.neighbor_swaps[(position-1,position)[new_direction=="up"]]
            return swap,hunts
            # move
            pass
        else:
            new_direction=("up","down")[direction=="up"]
            hunts[hunt]["direction"]=new_direction
            if hunt["next"]==None:
                return self.neighbor_swaps[(0,-1)[new_direction=="up"]], hunts
            else:
                return transposePermutation(getStepAsPermutation(domain,hunt),(0,1)[new_direction=="up"]), hunts
    def act(self,peal="rotation",domain=None):
        if domain==None:
            domain=list(range(self.nelements))
        return [i(domain) for i in self.peals[peal]]
    def actAll(self,domain=None):
        if domain==None:
            domain=list(range(self.nelements))
        acted_peals={}
        for peal in self.peals:
            acted_peals[peal+"_acted"]=[i(domain) for i in self.peals[peal]]
        self.domain=domain
        self.acted_peals=acted_peals
    def transpositionsPeal(permutation,peal_name="transposition_peal"):
        self.peals[peal_name]=[sympy.combinatorics.Permutation(i) for i in permutation.transpositions()]


