import sys
keys=tuple(sys.modules.keys())
for key in keys:
    if "music" in key:
        del sys.modules[key]
import music as M
from percolation.rdf import c
import sympy

class InterestingPermutations:
    """

    mirrors are ordered by swaps (0,n-1..)
    """
    def __init__(self,n_elements=4,method="dimino"):
        c("started permutations with",n_elements,"elements")
        self.n_elements=n_elements
        self.method=method
        self.getRotations()
        self.getMirrors()
        self.getAlternating()
        self.getFullSymmetry()
        self.getSwaps()
        c("finished permutations with",n_elements,"elements")
        pass
    def getAlternating(self):
        self.alternations=list(sympy.combinatorics.named_groups.AlternatingGroup(self.n_elements).generate(method=self.method))
        self.alternations_=[i for i in self.alternations if i not in self.dihedral]
        length=3
        self.alternations_by_sizes=[]
        while length in [i.length() for i in self.alternations_]:
            self.alternations_by_sizes+=[[i for i in self.alternations_ if i.length()==length]]
            length+=1
        assert len(self.alternations_)==sum([len(i) for i in self.alternations_by_sizes])

    def getRotations(self):
        """method dimino or coset"""
        self.rotations=list(sympy.combinatorics.named_groups.CyclicGroup(self.n_elements).generate(method=self.method))
    def getMirrors(self):
        self.dihedral=list(sympy.combinatorics.named_groups.DihedralGroup(self.n_elements).generate(method=self.method))
        self.mirrors=[i for i in self.dihedral if i not in self.rotations]
        if self.n_elements%2==0: # even elements have edge and vertex mirrors
            self.edge_mirrors=[i for i in   self.mirrors if i.length()==self.n_elements]
            self.vertex_mirrors=[i for i in self.mirrors if i.length()==self.n_elements-2]
            assert len(self.edge_mirrors+self.vertex_mirrors)==len(self.mirrors)
        pass
    def getSwaps(self):
        # contiguous swaps
        # swaps by distance between the indexes
        # indicate ordering of swaps to make peals
        pass
    def getFullSymmetry(self):
        self.permutations=list(sympy.combinatorics.named_groups.SymmetricGroup(self.n_elements).generate(method=self.method))
        # sympy.combinatorics.generators.symmetric(self.n_elements)
        pass
ip3=InterestingPermutations(3)
ip4=InterestingPermutations(4)
ip5=InterestingPermutations(5)
ip6=InterestingPermutations(6)
ip7=InterestingPermutations(7)
ip8=InterestingPermutations(8)

class Peals(InterestingPermutations):
    """Use permutations to make peals and represent peals as permutations"""
    def __init__(self):
        self.peals={}
        self.makeRotateHalfs() # original and the rotation r that r*r=e. Alternate r1*r2=e if nelements==odd
        self.makeMirror() # original and miror
        self.makeFullRotations() # original and each rotation clockwise (0->n-1)
        self.makeFullMirrors() # sequences to fit overall sizes or not..
        self.makeOtherFullCycles() # generated by permutations with all elements while not a rotation or a mirror. # non-topological?
        self.canonicalPeal() # with the hunts, etc. 
    def act(self,peal="rotation",domain=None):
        if domain=None:
            domain=list(range(self.nelements))
        return [i(domain) for i in self.peals[peal]]
    def actAll(self,domain=None):
        if domain=None:
            domain=list(range(self.nelements))
        acted_peals={}
        for peal in self.peals:
            acted_peals[peal+"_acted"]=[i(domain) for i in self.peals[peal]]
        self.domain=domain
        self.acted_peals=acted_peals

# Peals.mirror, .full_mirrors, .other_full_cycle are lists with final permutations
# Peal.

#ip9=InterestingPermutations(9)
    # swap all neighbors
    # if odd number of elements, keep first, last or middle element
    # all rotations
    # all mirrors
    # all swaps which dont fit where else
    # all permutations that fit nowherelse
    # subgroups




